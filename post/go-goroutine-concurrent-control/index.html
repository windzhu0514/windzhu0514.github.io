<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.48" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>goroutine并发控制 | 风竹的个人网站</title>
    <meta property="og:title" content="goroutine并发控制 - 风竹的个人网站">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2018-12-07T10:05:37&#43;08:00">
        
        
    <meta property="article:modified_time" content="2018-12-07T10:05:37&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,博客,C,C&#43;&#43;,mfc">
    <meta name="description" content="goroutine并发控制">
        
    <meta name="author" content="风竹">
    <meta property="og:url" content="https://ljc.space/post/go-goroutine-concurrent-control/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://ljc.space/">
                        风竹的个人网站
                    </a>
                
                <p class="description">C/C&#43;&#43;、MFC、Go语言(golang)开发者</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://ljc.space/">首页</a>
                    
                    <a  href="https://ljc.space/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">goroutine并发控制</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2018年12月7日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://ljc.space/categories/go">go</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<h2 id="通信">通信</h2>

<h4 id="共享内存">共享内存</h4>

<pre><code class="language-go">func  Test() {
    ordersInfoApp  :=  make([]orderInfoApp, 0, totalCount)
    var  mux sync.Mutex
    wg  := sync.WaitGroup{}

    for  i  :=  0; i &lt;=  10; i++ {
        wg.Add(1)
        go  func(pageIndex int) {
            // do somethine
            var  ordersInfo orderInfoApp
            mux.Lock()
            ordersInfoApp  =  append(ordersInfoApp, ordersInfo)
            mux.Unlock()

            wg.Done()
        }(i)
    }

    wg.Wait()
}
</code></pre>

<p>一般在简单的数据传递下使用</p>

<h4 id="channel">channel</h4>

<pre><code class="language-go">func  Test() {
    ordersInfoApp  :=  make([]orderInfoApp, 0, totalCount)
    choi  :=  make(chan orderInfoApp, 10)
    wg  := sync.WaitGroup{}

    for  i  :=  0; i &lt;=  10; i++ {
        wg.Add(1)
        go  func(pageIndex int) {
            // do somethine
            var  ordersInfo orderInfoApp
            choi &lt;- ordersInfo

            wg.Done()
        }(i)
    }

    go  func() {
        wg.Wait()
        close(choi)
    }()

    for  v  :=  range choi {
        ordersInfoApp  =  append(ordersInfoApp, v)
    }
}
</code></pre>

<p>相对复杂的数据流动情况</p>

<h2 id="同步和控制">同步和控制</h2>

<p>goroutine 退出只能由本身控制，不能从外部强制结束该 goroutine
两种例外情况：main 函数结束或者程序崩溃结束运行</p>

<h4 id="共享变量控制结束">共享变量控制结束</h4>

<pre><code class="language-go">func  main() {
    running  :=  true
    f  :=  func() {
        for running {
            fmt.Println(&quot;i am running&quot;)
            time.Sleep(1  * time.Second)
        }
        fmt.Println(&quot;exit&quot;)
    }
    go  f()
    go  f()
    go  f()
    time.Sleep(2  * time.Second)
    running  =  false
    time.Sleep(3  * time.Second)
    fmt.Println(&quot;main exit&quot;)
}
</code></pre>

<p><strong>优点</strong>：
实现简单，不抽象，方便，一个变量即可简单控制子 goroutine 的进行。
<strong>缺点</strong>:
结构只能是多读一写，不能适应结构复杂的设计，如果有多写，会出现数据同步问题，需要加锁或者使用 sync.atomic
不适合用于同级的子 go 程间的通信，全局变量传递的信息太少
因为是单向通知,主进程无法等待所有子 goroutine 退出
这种方法只适用于非常简单的逻辑且并发量不太大的场景</p>

<h4 id="sync-waitgroup-等待结束">sync.Waitgroup 等待结束</h4>

<pre><code class="language-go">func  main() {
    var  wg sync.WaitGroup
    for  i  :=  0; i &lt;  3; i++ {
        wg.Add(1)
        go  func() {
            defer wg.Done()
            // do something
        }()
    }

    wg.Wait()
}
</code></pre>

<h4 id="channel-控制结束">channel 控制结束</h4>

<pre><code class="language-go">// 可扩展到多个work
func  main() {
    chClose  :=  make(chan  struct{})
    go  func() {
        for {
            select {
                case  &lt;-chClose:
                    return
                default:
            }

        // do something
        }
    }()

    //chClose&lt;-struct{}
    close(chClose)
}
</code></pre>

<p>注意 channel 的阻塞情况，避免出现死锁。
通常 channel 只能由发送者关闭</p>

<ul>
<li><p>向无缓冲的 channel 写入数据会导致该 goroutine 阻塞，直到其他 goroutine 从这个 channel 中读取数据</p></li>

<li><p>从无缓冲的 channel 读出数据，如果 channel 中无数据，会导致该 goroutine 阻塞，直到其他 goroutine 向这个 channel 中写入数据</p></li>

<li><p>向带缓冲的且缓冲已满的 channel 写入数据会导致该 goroutine 阻塞，直到其他 goroutine 从这个 channel 中读取数据</p></li>

<li><p>向带缓冲的且缓冲未满的 channel 写入数据不会导致该 goroutine 阻塞</p></li>

<li><p>从带缓冲的 channel 读出数据，如果 channel 中无数据，会导致该 goroutine 阻塞，直到其他 goroutine 向这个 channel 中写入数据</p></li>

<li><p>从带缓冲的 channel 读出数据，如果 channel 中有数据，该 goroutine 不会阻塞</p>

<pre><code class="language-go">// 读完结束
for {
select {
case  &lt;-ch:
    default:
    goto finish
}
}
finish:
</code></pre></li>

<li><p>如果多个 case 同时就绪时，select 会随机地选择一个执行</p></li>

<li><p>case 标签里向 channel 发送或接收数据，case 后面的语句在发送接收成功后才会执行</p></li>

<li><p>nil channel（读、写、读写）的 case 标签会被跳过</p></li>
</ul>

<h4 id="limitwaitgroup">limitwaitgroup</h4>

<pre><code class="language-go">type  limitwaitgroup  struct {
    sem chan  struct{}
    wg sync.WaitGroup
}

func  New(n int) *limitwaitgroup {
    return  &amp;limitwaitgroup{
        sem: make(chan  struct{}, n),
    }
}

func  (l *limitwaitgroup) Add() {
    l.sem &lt;-  struct{}{}
    l.wg.Add(1)
}

func  (l *limitwaitgroup) Done() {
    &lt;-l.sem
    l.wg.Done()
}

func  (l *limitwaitgroup) Wait() {
    l.wg.Wait()
}

// 例子
wg  := limitwaitgroup.New(6)
for  i  :=  0; i &lt;=  10; i++ {
    wg.Add()
    go  func(index int){
        defer wg.Done()
        // do something
    }(i)
}
wg.Wait()
</code></pre>

<h4 id="context">context</h4>

<p>上下文 go 1.7 作为第一个参数在 goroutine 里传递</p>

<p>Context 的接口定义</p>

<pre><code class="language-go">type  Context  interface {
    Deadline() (deadline time.Time, ok bool)
    Done() &lt;-chan  struct{}
    Err() error
    Value(key interface{}) interface{}
}
</code></pre>

<p><code>Deadline</code>获取设置的截止时间(WithDeadline、WithTimeout)， 第一个返回值代表截止时间，第二个返回值代表是否设置了截止时间，false 时表示没有设置截止时间</p>

<p><code>Done</code>方法返回一个关闭的只读的 chan，类型为<code>struct{}</code>，在 goroutine 中，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求，我们通过<code>Done</code>方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源。</p>

<p><code>Err</code>context 没有被结束，返回 nil；已被结束，返回结束的原因（被取消、超时）。</p>

<p><code>Value</code>方法通过一个 Key 获取该 Context 上绑定的值，访问这个值是线程安全的。key 一般定义当前包的一个新的未导出类型的变量（最好不要使用内置类型），避免和其他 goroutine 的 key 冲突。</p>

<ul>
<li>Context 衍生</li>
</ul>

<pre><code class="language-go">func  WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func  WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func  WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func  WithValue(parent Context, key, val interface{}) Context
</code></pre>

<p>这四个<code>With</code>函数，接收的都有一个 partent 参数，就是父 Context，我们要基于这个父 Context 创建出子 Context 的意思，这种方式可以理解为子 Context 对父 Context 的继承，也可以理解为基于父 Context 的衍生。</p>

<p>通过这些函数，就创建了一颗 Context 树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。</p>

<p><code>WithCancel</code>函数，传递一个父 Context 作为参数，返回子 Context，以及一个取消函数用来取消 Context。 <code>WithDeadline</code>函数，和<code>WithCancel</code>差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消 Context，也可以不等到这个时候，可以提前通过取消函数进行取消。</p>

<p><code>WithTimeout</code>和<code>WithDeadline</code>基本上一样，这个表示是超时自动取消，设置多少时间后自动取消 Context。</p>

<p><code>WithValue</code>函数和取消 Context 无关，生成一个绑定了一个键值对数据的 Context，这个绑定的数据可以通过<code>Context.Value</code>方法访问到</p>

<ul>
<li>例子</li>
</ul>

<p>WithCancel</p>

<pre><code class="language-go">func  main() {
    ctx, cancel  := context.WithCancel(context.Background())
    go  watch(ctx, &quot;goroutine 1&quot;)
    go  watch(ctx, &quot;goroutine 2&quot;)
    go  watch(ctx, &quot;goroutine 3&quot;)
    time.Sleep(10  * time.Second)
    fmt.Println(&quot;开始结束goroutine&quot;)
    cancel()
    time.Sleep(5  * time.Second)
    fmt.Println(ctx.Err())
}
func  watch(ctx context.Context, name string) {
  for {
      select {
      case  &lt;-ctx.Done():
          fmt.Println(name, &quot;over&quot;)
          return
      default:
          fmt.Println(name, &quot;running&quot;)
          time.Sleep(2  * time.Second)
      }
  }
}

// output:
goroutine 1 running
goroutine 2 running
goroutine 3 running
goroutine 1 running
goroutine 2 running
goroutine 3 running
goroutine 1 running
goroutine 2 running
goroutine 3 running
goroutine 2 running
goroutine 3 running
goroutine 1 running
goroutine 3 running
goroutine 2 running
goroutine 1 running
开始结束goroutine
goroutine 1 over
goroutine 2 over
goroutine 3 over
context canceled
</code></pre>

<p>WithDeadline</p>

<pre><code class="language-go">func  main() {
    ctx, cancel  := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))
    go  watch(ctx, &quot;goroutine 1&quot;)
    go  watch(ctx, &quot;goroutine 2&quot;)
    go  watch(ctx, &quot;goroutine 3&quot;)
    _  = cancel
    time.Sleep(8  * time.Second)
    fmt.Println(ctx.Err())
}

func  watch(ctx context.Context, name string) {
  for {
      select {
      case  &lt;-ctx.Done():
          fmt.Println(name, &quot;over&quot;)
          return
      default:
          fmt.Println(name, &quot;running&quot;)
          time.Sleep(2  * time.Second)
      }
  }
}

// output:
goroutine 3 running
goroutine 2 running
goroutine 1 running
goroutine 3 running
goroutine 1 running
goroutine 2 running
goroutine 1 running
goroutine 3 running
goroutine 2 running
goroutine 3 over
goroutine 1 over
goroutine 2 over
context deadline exceeded
</code></pre>

<p>WithTimeout</p>

<pre><code class="language-go">func  main() {
    ctx, cancel  := context.WithTimeout(context.Background(), 5*time.Second)
    go  watch(ctx, &quot;goroutine 1&quot;)
    go  watch(ctx, &quot;goroutine 2&quot;)
    go  watch(ctx, &quot;goroutine 3&quot;)
    _  = cancel
    time.Sleep(8  * time.Second)
    fmt.Println(ctx.Err())
}

func  watch(ctx context.Context, name string) {
  for {
      select {
      case  &lt;-ctx.Done():
          fmt.Println(name, &quot;over&quot;)
          return
      default:
          fmt.Println(name, &quot;running&quot;)
          time.Sleep(2  * time.Second)
      }
  }
}

// output:
goroutine 3 running
goroutine 1 running
goroutine 2 running
goroutine 3 running
goroutine 2 running
goroutine 1 running
goroutine 2 running
goroutine 1 running
goroutine 3 running
goroutine 2 over
goroutine 3 over
goroutine 1 over
context deadline exceeded
</code></pre>

<p>WithValue</p>

<pre><code class="language-go">type  key  int  // 未导出的包私有类型
var  kkk key =  0

func  main() {
    ctx, cancel  := context.WithCancel(context.Background())
    // WithValue是没有取消函数的
    ctx  = context.WithValue(ctx, kkk, &quot;100W&quot;)

    go  watch(ctx, &quot;goroutine 1&quot;)
    go  watch(ctx, &quot;goroutine 2&quot;)
    go  watch(ctx, &quot;goroutine 3&quot;)

    time.Sleep(8  * time.Second)

    fmt.Println(&quot;开始结束goroutine&quot;)
    cancel()

    time.Sleep(3  * time.Second)
    fmt.Println(ctx.Err())
}

func  watch(ctx context.Context, name string) {
  for {
      select {
      case  &lt;-ctx.Done():
          fmt.Println(name, &quot;over&quot;)
          return
      default:
          fmt.Println(name, &quot;running&quot;, &quot;爸爸给我了&quot;, ctx.Value(kkk).(string))
          time.Sleep(2  * time.Second)
      }
  }
}
// output:
goroutine 1 running 爸爸给我了 100W
goroutine 2 running 爸爸给我了 100W
goroutine 3 running 爸爸给我了 100W
goroutine 2 running 爸爸给我了 100W
goroutine 1 running 爸爸给我了 100W
goroutine 3 running 爸爸给我了 100W
goroutine 1 running 爸爸给我了 100W
goroutine 2 running 爸爸给我了 100W
goroutine 3 running 爸爸给我了 100W
goroutine 1 running 爸爸给我了 100W
goroutine 3 running 爸爸给我了 100W
goroutine 2 running 爸爸给我了 100W
开始结束goroutine
goroutine 2 over
goroutine 3 over
goroutine 1 running 爸爸给我了 100W
goroutine 1 over
context canceled
</code></pre>

<p>控制多个 goroutine</p>

<pre><code class="language-go">func  main() {
    http.HandleFunc(&quot;/&quot;, func(W http.ResponseWriter, r *http.Request) {
    fmt.Println(&quot;收到请求&quot;)

    ctx, cancel  := context.WithCancel(context.Background())
    go  worker(ctx, 2)
    go  worker(ctx, 3)

    time.Sleep(time.Second *  10)
    cancel()
    fmt.Println(ctx.Err())
    })
    http.ListenAndServe(&quot;:9290&quot;, nil)
}
func  worker(ctx context.Context, speed int) {
    reader  :=  func(n int) {
        for {
            select {
                case  &lt;-ctx.Done():
                return
                default:
                break
            }
            fmt.Println(&quot;reader:&quot;, n)
            time.Sleep(time.Duration(n) * time.Second)
        }
    }

    go  reader(2)
    go  reader(1)

    for {
        select {
            case  &lt;-ctx.Done():
            return
            default:
            break
        }
        fmt.Println(&quot;worker:&quot;, speed)
        time.Sleep(time.Duration(speed) * time.Second)
    }
}

// output:
收到请求
worker: 2
reader: 1
worker: 3
reader: 1
reader: 2
reader: 2
reader: 1
reader: 1
reader: 1
reader: 2
worker: 2
reader: 2
reader: 1
reader: 1
reader: 1
worker: 3
reader: 1
worker: 2
reader: 2
reader: 1
reader: 2
reader: 1
context canceled
</code></pre>

<ul>
<li><p>使用规则
使用 Context 的程序应遵循以下这些规则来保持跨包接口的一致和方便静态分析工具(go vet)来检查上下文传播是否有潜在问题。</p>

<ul>
<li><p>不要将 Context 存储在结构类型中，而是显式的传递给每个需要的函数； Context 应该作为函数的第一个参数传递，通常命名为 ctx：</p>

<pre><code class="language-go">func  DoSomething(ctx context.Context, arg Arg) error {
// ... use ctx ...
}
</code></pre></li>

<li><p>即使函数可以接受 nil 值，也不要传递 nil Context。如果不确定要使用哪个 Context，请传递 context.TODO。</p></li>

<li><p>使用 context 的 Value 相关方法只应该用于在程序和接口中传递和请求相关的元数据，不要用它来传递一些可选的参数</p></li>

<li><p>相同的 Context 可以传递给在不同 goroutine 中运行的函数; Context 对于多个 goroutine 同时使用是安全的。</p></li>
</ul></li>
</ul>

                        </div>

                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/go-get-progress/">go get添加进度</a></li>
        
        <li><a href="/post/markdown/">Markdown 基本语法</a></li>
        
        <li><a href="/about/">关于我</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://ljc.space/tags/go">go</a></li>
                                
                                <li><a href="https://ljc.space/tags/goroutine">goroutine</a></li>
                                
                                <li><a href="https://ljc.space/tags/%E5%B9%B6%E5%8F%91">并发</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "windzhu0514/windzhu0514.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://ljc.space/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://ljc.space/post/multiple-git-account/" title="git多账户共存">git多账户共存</a>
    </li>
    
    <li>
        <a href="https://ljc.space/post/go-goroutine-concurrent-control/" title="goroutine并发控制">goroutine并发控制</a>
    </li>
    
    <li>
        <a href="https://ljc.space/post/go-get-progress/" title="go get添加进度">go get添加进度</a>
    </li>
    
    <li>
        <a href="https://ljc.space/post/markdown/" title="Markdown 基本语法">Markdown 基本语法</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://ljc.space/categories/git/">git(1)</a>
    </li>
    
    <li>
        <a href="https://ljc.space/categories/go/">go(1)</a>
    </li>
    
    <li>
        <a href="https://ljc.space/categories/golang/">golang(1)</a>
    </li>
    
    <li>
        <a href="https://ljc.space/categories/markdown/">markdown(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://ljc.space/tags/git/">git</a>
    
    <a href="https://ljc.space/tags/go/">go</a>
    
    <a href="https://ljc.space/tags/goroutine/">goroutine</a>
    
    <a href="https://ljc.space/tags/markdown/">markdown</a>
    
    <a href="https://ljc.space/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://ljc.space/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2018 <a href="https://ljc.space/">风竹的个人网站 By 风竹</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="http://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
