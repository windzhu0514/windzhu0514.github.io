<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on 一蓑烟雨任平生</title><link>/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on 一蓑烟雨任平生</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 07 Dec 2018 10:05:37 +0800</lastBuildDate><atom:link href="/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>goroutine并发控制</title><link>/post/go-goroutine-concurrent-control/</link><pubDate>Fri, 07 Dec 2018 10:05:37 +0800</pubDate><guid>/post/go-goroutine-concurrent-control/</guid><description>通信 共享内存 func Test() { ordersInfoApp := make([]orderInfoApp, 0, totalCount) var mux sync.Mutex wg := sync.WaitGroup{} for i := 0; i &amp;lt;= 10; i++ { wg.Add(1) go func(pageIndex int) { // do somethine var ordersInfo orderInfoApp mux.Lock() ordersInfoApp = append(ordersInfoApp, ordersInfo) mux.Unlock() wg.Done() }(i) } wg.Wait() } 一般在简单的数据传递下使用 channel func Test() { ordersInfoApp :=</description></item></channel></rss>