<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发 on 一蓑烟雨任平生</title>
    <link>https://ljc.space/tags/%E5%B9%B6%E5%8F%91/</link>
    <description>Recent content in 并发 on 一蓑烟雨任平生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 07 Dec 2018 10:05:37 +0800</lastBuildDate>
    
	<atom:link href="https://ljc.space/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>goroutine并发控制</title>
      <link>https://ljc.space/post/go-goroutine-concurrent-control/</link>
      <pubDate>Fri, 07 Dec 2018 10:05:37 +0800</pubDate>
      
      <guid>https://ljc.space/post/go-goroutine-concurrent-control/</guid>
      <description>通信 共享内存 func Test() { ordersInfoApp := make([]orderInfoApp, 0, totalCount) var mux sync.Mutex wg := sync.WaitGroup{} for i := 0; i &amp;lt;= 10; i++ { wg.Add(1) go func(pageIndex int) { // do somethine var ordersInfo orderInfoApp mux.Lock() ordersInfoApp = append(ordersInfoApp, ordersInfo) mux.Unlock() wg.Done() }(i) } wg.Wait() }  一般在简单的数据传递下使用
channel func Test() { ordersInfoApp := make([]orderInfoApp, 0, totalCount) choi := make(chan orderInfoApp, 10) wg := sync.WaitGroup{} for i := 0; i &amp;lt;= 10; i++ { wg.Add(1) go func(pageIndex int) { // do somethine var ordersInfo orderInfoApp choi &amp;lt;- ordersInfo wg.Done() }(i) } go func() { wg.Wait() close(choi) }() for v := range choi { ordersInfoApp = append(ordersInfoApp, v) } }  相对复杂的数据流动情况
同步和控制 goroutine 退出只能由本身控制，不能从外部强制结束该 goroutine 两种例外情况：main 函数结束或者程序崩溃结束运行
共享变量控制结束 func main() { running := true f := func() { for running { fmt.Println(&amp;quot;i am running&amp;quot;) time.Sleep(1 * time.Second) } fmt.</description>
    </item>
    
  </channel>
</rss>